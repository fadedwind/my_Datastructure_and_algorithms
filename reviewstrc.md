
# linked_list,queue and stack 链表，队列和栈

linked_list 是一种数据结构，通常翻译为"链表"。链表是由节点（Node）组成的数据结构，每个节点包含数据域和指向下一个节点的指针（或引用）。链表中的节点可以动态分配，相比数组，链表的大小可以动态变化。

现在来梳理一下链表、队列和栈的关系和区别：

>链表（Linked List）：

结构： 由节点组成，每个节点包含数据和指向下一个节点的指针。
特点： 大小动态可变，内存不是连续的。
常见操作： 插入和删除节点的操作效率高，但随机访问的效率较低。

>队列（Queue）：

结构： 具有先进先出（FIFO）的特点，可以用数组或链表实现。
特点： 只能在队头删除元素，在队尾插入元素。
常见操作： 入队（enqueue）和出队（dequeue）。

>栈（Stack）：

结构： 具有后进先出（LIFO）的特点，可以用数组或链表实现。
特点： 只能在栈顶进行插入和删除元素。
常见操作： 压栈（push）和弹栈（pop）。
联系与区别：

联系： 链表可以用于实现队列和栈。在队列中，链表的头部（或尾部）用作队头（或队尾），而在栈中，整个链表可以被看作是一个栈。
区别：
队列和栈的操作限制： 队列只允许在队头删除元素，在队尾插入元素；栈只允许在栈顶插入和删除元素。链表在任何位置都可以插入和删除节点。
访问效率： 链表的随机访问效率相对较低，而队列和栈的随机访问效率较高。

总的来说，链表是一种基础的数据结构，而队列和栈则是基于特定规则限制的数据结构，可以用链表实现。链表的灵活性更高，而队列和栈更专注于某些特定的操作规则。

# 排序算法

## comparison based sorting

    Selection sort
    Bubble Sort
    Insertion Sort
    Shell Sort
    Merge Sort
    Quick Sort
    Heap Sort

>选择排序 (Selection Sort)    O(n^2)
选择排序的核心思想是从未排序的部分中选择最小（或最大）的元素，并将其与未排序部分的第一个元素交换位置。通过重复这个过程，每次选择剩余未排序部分的最小（或最大）元素，直到整个数组有序为止。

时间复杂度：
最坏情况：O(n^2)
最好情况：O(n^2)
平均情况：O(n^2)
空间复杂度：O(1)
>堆排序 (Heap Sort)-----可视为选择排序的改进    O(nlogn)
堆排序的核心思想是将待排序的数组构建成一个二叉堆（最大堆或最小堆），然后反复将堆顶元素（最大或最小元素）与数组末尾的元素交换，并将堆的大小减小，再进行堆调整操作，直到整个数组有序。堆排序利用了堆的性质和操作，是一种高效的排序算法。

时间复杂度：
最坏情况：O(nlogn)
最好情况：O(nlogn)
平均情况：O(nlogn)
空间复杂度：O(1)

>冒泡排序 (Bubble Sort)    O(n^2)
冒泡排序的核心思想是通过相邻元素的比较和交换，将较大（或较小）的元素逐步“冒泡”到数组的末尾。重复比较相邻元素并交换它们的位置，直到整个数组有序。

时间复杂度：
最坏情况：O(n^2)
最好情况：O(n)
平均情况：O(n^2)
空间复杂度：O(1)

>插入排序 (Insertion Sort)    O(n^2)
插入排序的核心思想是将数组分为已排序和未排序两部分，逐个将未排序部分的元素插入到已排序部分的正确位置。它在每次迭代中将一个元素插入到已排序部分，逐步扩大已排序部分的范围，直到整个数组有序。

时间复杂度：
最坏情况：O(n^2)
最好情况：O(n)
平均情况：O(n^2)
空间复杂度：O(1)
>希尔排序 (Shell Sort)-----可视为插入排序的一种改进     O(n^2)
希尔排序的核心思想是通过比较相隔一定间隔的元素，并交换它们的位置，逐步减小间隔的大小，直到间隔为1，最终使整个数组变得基本有序。希尔排序是插入排序的一种改进形式，通过提前将较小的元素移动到前面，可以更快地减少逆序对的数量。

时间复杂度：
最坏情况：取决于间隔序列的选择，一般为O(n^2)
最好情况：O(nlogn)
平均情况：取决于间隔序列的选择，一般为O(n^1.3)
空间复杂度：O(1)

>归并排序 (Merge Sort)    O(nlogn)
归并排序的核心思想是将一个数组分成两个较小的子数组，递归地对子数组进行排序，然后将排序后的子数组合并成一个有序的数组。它使用了分治策略，先将问题分解成更小的子问题，然后解决子问题并将结果合并以获得原始问题的解决方案。

时间复杂度：
最坏情况：O(nlogn)
最好情况：O(nlogn)
平均情况：O(nlogn)
空间复杂度：O(n)

>快速排序 (Quick Sort)     O(nlogn)中最快
快速排序的核心思想是选择一个主元（pivot），然后将数组划分为两个部分，使得主元左侧的元素都小于主元，右侧的元素都大于主元。随后，对两个部分递归地应用相同的方法，直到整个数组有序。快速排序是一种高效的排序算法，它使用了分治策略和递归。

时间复杂度：
最坏情况：O(n^2)（当数组已经有序时）
最好情况：O(nlogn)
平均情况：O(nlogn)
空间复杂度：O(logn)

## Non-comparison based sorting

    Counting sort
    Bucket sort
    Radix sort

>计数排序 (Counting Sort)
计数排序的核心思想是统计数组中每个元素的出现次数，并根据计数结果重建一个有序的数组。它适用于一定范围内的整数排序，时间复杂度较低。

时间复杂度：O(n+k)，其中k是整数的范围
空间复杂度：O(n+k)

>桶排序 (Bucket Sort)
桶排序的核心思想是将待排序数组划分为一定数量的桶，然后将元素分配到各个桶中，再对每个桶进行排序，最后将各个桶中的元素合并得到有序数组。桶排序适用于元素分布均匀的情况。

时间复杂度：
最坏情况：O(n^2)
最好情况：O(n+k)，其中k是桶的数量
平均情况：O(n)
空间复杂度：O(n+k)

>基数排序 (Radix Sort)
基数排序是一种非比较的排序算法，它根据元素的位数逐位进行排序。基本思想是首先按照最低有效位的大小将元素进行排序，然后按照次低有效位的大小进行排序，依此类推，直到最高有效位完成排序。基数排序可以使用稳定的排序算法作为其内部排序方法，例如计数排序或桶排序。

时间复杂度：
最坏情况：O(d*(n + k))，其中d是最大元素的位数，n是元素数量，k是基数的范围
最好情况：O(d*(n + k))
平均情况：O(d*(n + k))
空间复杂度：O(n + k)，其中k是基数的范围
基数排序的性能取决于元素的位数，因此它在处理较大范围的整数或固定长度的键时效果很好。然而，对于浮点数或变长键，基数排序可能不太适用。此外，基数排序的时间复杂度相对较高，因此在某些情况下，其他排序算法可能更加高效。

>小结：
>排序算法   时间复杂度   空间复杂度   稳定性
>选择排序   O(n^2)      O(1)       可能稳定，可能不稳定
>堆排序    O(nlogn)     O(1)       不稳定
>冒泡排序   O(n^2)      O(1)       稳定
>插入排序   O(n^2)      O(1)       稳定
>希尔排序   O(n^2)      O(1)       不稳定
>归并排序   O(nlogn)    O(n)       稳定
>快速排序  O(NlogN)    O(logN)     不稳定
